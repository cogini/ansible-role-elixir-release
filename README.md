# elixir-release

This Ansible role deploys Elixir/Phoenix releases.
It uses Erlang "releases" with systemd for process supervision.

## Directory structure

It uses a structure like Capistrano to manage the release files.  The base
directory is named for the app, e.g. `/srv/foo`.  Under that, it creates a
`releases` directory.  When deploying a release, it creates a directory under
`releases` named by a timestamp, e.g. `/srv/foo/releases/20190603T072116`.  It
then makes a `/srv/foo/current` to the new directory and restarts the app.

## Restarting

After deploying the release, we restart the app to make it live:

```shell
sudo /bin/systemctl restart foo
```

The deploy user account needs sufficient permissions to restart the app.
Instead of giving the deploy account full sudo permissions, a
user-specific sudo config file specifies what commands it can run, e.g.
`/etc/sudoers.d/deploy-foo`:

    deploy ALL=(ALL) NOPASSWD: /bin/systemctl start foo, /bin/systemctl stop foo, /bin/systemctl restart foo

Better is if we didn't require sudo permissions at all. One option is to take
advantage of the supervision provided by systemd to restart the app.

When we deploy a new release, the deploy user uploads the new code, sets up the
symlink, then tells the app to restart by touching a flag file on the disk.
Systemd notices and restarts it with the new code.

See https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ for background.
and https://github.com/cogini/mix-deploy-example for a full example.

# Requirements

None

# Role Variables

Erlang name of the application, used to by Distillery to name directories
and scripts.

    elixir_release_app_name: my_app

External name of the app, used to name the systemd service and directories:

    elixir_release_service_name: "{{ elixir_release_app_name | replace('_', '-') }}"

Elixir application name, normally the CamelCase version of the app name:

    elixir_release_app_module: "{{ elixir_release_service_name.title().replace('_', '') }}"

Version of the app in the release. If not specified, will read it from a file
in the release.

    elixir_release_version: "0.1.0"

OS account that deploys and owns the release files:

    elixir_release_deploy_user: deploy

OS group that deploys and owns the release files:

    elixir_release_deploy_group: "{{ elixir_release_deploy_user }}"

OS account that the app runs under:

    elixir_release_app_user: "{{ elixir_release_service_name }}"

OS group that the app runs under:

    elixir_release_app_group: "{{ elixir_release_app_user }}"

App release environment, i.e. the setting of `MIX_ENV`:

    elixir_release_mix_env: prod

Port that the app listens for HTTP connections on:

    elixir_release_http_listen_port: 4000

Port that the app listens for HTTPS connections on:

    elixir_release_https_listen_port: 4001

Directory prefix for release files:

    elixir_release_base_dir: /srv

Base directory for deploy files:

    elixir_release_deploy_dir: "{{ elixir_release_base_dir }}/{{ elixir_release_service_name }}"

Directories under deploy dir.

Where release tarballs are unpacked:

    elixir_release_releases_dir: "{{ elixir_release_deploy_dir }}/releases"

Currently running release (symlink):

    elixir_release_current_dir: "{{ elixir_release_deploy_dir }}/current"

Location of deploy scripts:

    elixir_release_scripts_dir: "{{ elixir_release_deploy_dir }}/bin"

Flag file dir, used to signal restart:

    elixir_release_flags_dir: "{{ elixir_release_deploy_dir }}/flags"

Directories where the app keeps its files, following [systemd](https://www.freedesktop.org/software/systemd/man/systemd.exec.html).

    elixir_release_app_dirs:
      - configuration
      - runtime
      # - logs
      # - tmp
      # - state
      # - cache

Whether to use [conform](https://github.com/bitwalker/conform):

    elixir_release_conform: false
    elixir_release_conform_conf_path: "{{ elixir_release_configuration_dir }}/config.conform"

How we should restart the app:

    elixir_release_restart_method: systemctl
    # elixir_release_restart_method: systemd_flag
    # elixir_release_restart_method: touch

Options are:

* `systemctl`, which runs `systemctl restart foo`
* `systemd_flag`, which touches a file in `{{ elixir_release_shutdown_flags_dir }}/restart.flag`


Following are some options used when generating the systemd unit file. Generally speaking,
you are probably better off using [mix_systemd](https://hex.pm/packages/mix_systemd).

Open file limit:

    elixir_release_limit_nofile: 65536

Seconds to wait between restarts:

    elixir_release_systemd_restart_sec: 5

`LANG` environment var: 

    elixir_release_lang: "en_US.UTF-8"

umask:

    elixir_release_umask: "0027"

Target systemd version, used to enable more advanced features:

    elixir_release_systemd_version: 219

Source of systemd unit file:

    elixir_release_systemd_source: mix_systemd # copy files generated by mix_systemd in _build dir
    # elixir_release_systemd_source: self # generate using this role templates
    # elixir_release_scripts_source: self # generate using this role templates
    # elixir_release_scripts_source: mix_systemd # copy files generated by mix_systemd in _build dir
    elixir_release_scripts_source: bin # copy files generated by mix_deploy in bin dir

Systemd service type:

    elixir_release_service_type: simple

Start command:

    elixir_release_start_command: foreground

PID file when using forking service type:

    elixir_release_pid_file: "{{ elixir_release_runtime_dir }}/{{ elixir_release_app_name}}.pid"

List of ExecStartPre scripts in systemd unit file:

    elixir_release_exec_start_pre: []

List of environment vars to set in systemd unit file:

    elixir_release_env_vars: []

# Dependencies

None

# Example Playbook

    - hosts: '*'
      become: true
      roles:
        - cogini.elixir-release

Run setup tasks, e.g. installing packages and creating directories.
Run this from your dev machine, specifying a user with sudo permissions.

    ansible-playbook -u $USER -v -l web-servers playbooks/deploy-app.yml --skip-tags deploy -D

Deploy the code. Run this from the build server, from a user account with ssh
access to the deploy account on the target machine.

    ansible-playbook -u deploy -v -l web-servers playbooks/deploy-app.yml --tags deploy --extra-vars ansible_become=false -D

# License

MIT

# Author Information

Jake Morrison <jake@cogini.com>
